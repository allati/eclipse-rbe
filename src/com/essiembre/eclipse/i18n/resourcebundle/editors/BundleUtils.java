/*
 * Copyright (C) 2003, 2004  Pascal Essiembre, Essiembre Consultant Inc.
 * 
 * This file is part of Essiembre ResourceBundle Editor.
 * 
 * Essiembre ResourceBundle Editor is free software; you can redistribute it 
 * and/or modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 * 
 * Essiembre ResourceBundle Editor is distributed in the hope that it will be 
 * useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with Essiembre ResourceBundle Editor; if not, write to the 
 * Free Software Foundation, Inc., 59 Temple Place, Suite 330, 
 * Boston, MA  02111-1307  USA
 */
package com.essiembre.eclipse.i18n.resourcebundle.editors;

import java.net.MalformedURLException;
import java.net.URL;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.eclipse.jface.preference.IPreferenceStore;
import org.eclipse.jface.resource.ImageDescriptor;
import org.eclipse.swt.graphics.Image;

import com.essiembre.eclipse.i18n.resourcebundle.ResourceBundlePlugin;
import com.essiembre.eclipse.i18n.resourcebundle.preferences.RBPreferences;

/**
 * Provides utility methods for formatting an editor content. 
 * @author Pascal Essiembre
 * @version $Author$ $Revision$ $Date$
 */
public final class BundleUtils {

    /** Generator header comment. */
    private static final String GENERATOR = 
            "Generated by ResourceBundle Editor "
          + "(http://eclipse-rbe.sourceforge.net)";

    /** System line separator. */
    private static final String LINE_SEPARATOR = 
            System.getProperty("line.separator");
    
    /**
     * Constructor.
     */
    private BundleUtils() {
        super();
    }

    /**
     * Generate ressource bundle header comments.
     * @param comments comments to add
     * @return property file content
     */
    public static String generateComments(List comments) {
        StringBuffer text = new StringBuffer();

        if (RBPreferences.getShowGenerator()
                && (comments.size() == 0 
                       || !((String) comments.get(0)).startsWith(GENERATOR))) {
            text.append("#");
            text.append(GENERATOR);
            text.append(LINE_SEPARATOR);
        }
        for (int i = 0; i < comments.size(); i++) {
            String comment = (String) comments.get(i);
            text.append("#");
            text.append(comment);
            text.append(LINE_SEPARATOR);
        }
        return text.toString();
    }
    
    /**
     * Formats a resource bundle data.  Converts Map to a property file,
     * according to plugin preference store.
     * @param data data to convert
     * @return property file content
     */
    public static String generateContent(Map data) {
        String lineBreak = LINE_SEPARATOR;
        int numOfLineBreaks = RBPreferences.getGroupLineBreaks();
        
        // Format
        String group = null;
        int equalIndex = -1;
        StringBuffer text = new StringBuffer();
        for (Iterator iter = data.keySet().iterator(); iter.hasNext();) {
            String key = (String) iter.next();
            String value = (String) data.get(key);
            
            // handle group equal align and line break options
            if (RBPreferences.getGroupKeys()) {
                String newGroup = getKeyGroup(key);
                if (newGroup == null || !newGroup.equals(group)) {
                    group = newGroup;
                    equalIndex = getEqualIndex(key, group, data);
                    for (int i = 0; i < numOfLineBreaks; i++) {
                        text.append(lineBreak);
                    }
                }
            } else {
                equalIndex = getEqualIndex(key, null, data);
            }
            
            // Build line
            appendKey(text, key, equalIndex);
            appendValue(text, value, equalIndex);
            text.append(lineBreak);
        }
        return text.toString();
    }
    
    /**
     * Gets the position where the equal sign should be located for
     * the given group.
     * @param key resource bundle key
     * @param group resource bundle key group
     * @param data bundle content
     * @return position
     */
    private static int getEqualIndex(String key, String group, Map data) {
        int equalIndex = -1;
        boolean alignEquals = RBPreferences.getAlignEqualSigns();
        boolean groupKeys = RBPreferences.getGroupKeys();
        boolean groupAlignEquals = RBPreferences.getGroupAlignEqualSigns();

        // Exit now if we are not aligning equals
        if (!alignEquals || groupKeys && !groupAlignEquals 
                         || groupKeys && group == null) {
            return key.length();
        }
        
        // Get equal index
        for (Iterator iter = data.keySet().iterator(); iter.hasNext();) {
            String iterKey = (String) iter.next();
            if (!groupKeys || groupAlignEquals && iterKey.startsWith(group)) {
                int index = iterKey.length();
                if (index > equalIndex) {
                    equalIndex = index;
                }
            }
        }        
        return equalIndex;
    }
    
    /**
     * Appends a key to resource bundle content.
     * @param text the resource bundle content so far
     * @param value the value to add
     * @param equalIndex the equal sign position
     */
    private static void appendValue(
            StringBuffer text, String value, int equalIndex) {
        if (value != null) {
            int lineLength = RBPreferences.getWrapCharLimit() - 1;
            int valueStartPos = equalIndex + 3;
            if (RBPreferences.getWrapLines() && valueStartPos < lineLength) {
                StringBuffer valueBuf = new StringBuffer(value);
                while (valueBuf.length() + valueStartPos > lineLength) {
                    int endPos = lineLength - valueStartPos;
                    String line = valueBuf.substring(0, endPos);
                    int lastSpacePost = line.lastIndexOf(' ');
                    if (lastSpacePost != -1) {
                        endPos = lastSpacePost + 1;
                    }
                    text.append(valueBuf.substring(0, endPos));
                    text.append("\\");
                    text.append(LINE_SEPARATOR);
                    valueBuf.delete(0, endPos);
                    // Figure out starting position for next line
                    if (!RBPreferences.getWrapAlignEqualSigns()) {
                        valueStartPos = RBPreferences.getWrapIndentSpaces();
                    }
                    for (int i = 0; i < valueStartPos; i++) {
                        text.append(' ');
                    }
                }
                text.append(valueBuf);
            } else {
                text.append(value);
            }
        }
    }

    /**
     * Appends a value to resource bundle content.
     * @param text the resource bundle content so far
     * @param value the value to add
     * @param equalIndex the equal sign position
     */
    private static void appendKey(
            StringBuffer text, String key, int equalIndex) {
        text.append(key);
        for (int i = 0; i < equalIndex - key.length(); i++) {
            text.append(' ');
        }
        text.append(" = ");
    }
    
    /**
     * Gets the group from a resource bundle key.
     * @param key the key to get a group from
     * @return key group
     */
    public static String getKeyGroup(String key) {
        IPreferenceStore prefs = 
                ResourceBundlePlugin.getDefault().getPreferenceStore();

        String sep = RBPreferences.getKeyGroupSeparator();
        int deepness = RBPreferences.getGroupLevelDeepness();
        int endIndex = 0;
        int levelFound = 0;
        
        for (int i = 0; i < deepness; i++) {
            int sepIndex = key.indexOf(sep, endIndex);
            if (sepIndex != -1) {
                endIndex = sepIndex + 1;
                levelFound++;
            }
        }
        if (levelFound != 0) {
            if (levelFound < deepness) {
                return key;
            }
            return key.substring(0, endIndex - 1);
        }
        return null;
    }

    /**
     * Loads an image.
     * @param path image path, relative to plugin
     * @return image
     */
    public static Image loadImage(String path) {
        URL url = null;
        try {
        url = new URL(ResourceBundlePlugin.getDefault().getBundle().getEntry(
                "/"), path);
        } catch (MalformedURLException e) {
        }
        return ImageDescriptor.createFromURL(url).createImage();
    }

}
