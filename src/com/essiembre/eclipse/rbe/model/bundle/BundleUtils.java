/*
 * Copyright (C) 2003, 2004  Pascal Essiembre, Essiembre Consultant Inc.
 * 
 * This file is part of Essiembre ResourceBundle Editor.
 * 
 * Essiembre ResourceBundle Editor is free software; you can redistribute it 
 * and/or modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 * 
 * Essiembre ResourceBundle Editor is distributed in the hope that it will be 
 * useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with Essiembre ResourceBundle Editor; if not, write to the 
 * Free Software Foundation, Inc., 59 Temple Place, Suite 330, 
 * Boston, MA  02111-1307  USA
 */
package com.essiembre.eclipse.rbe.model.bundle;

import java.util.Iterator;

import org.eclipse.jface.preference.IPreferenceStore;

import com.essiembre.eclipse.rbe.ui.RBEPlugin;
import com.essiembre.eclipse.rbe.ui.preferences.RBEPreferences;

//TODO move this class or most of it to UI layer

/**
 * Bundle-related utility methods. 
 * @author Pascal Essiembre (essiembre@users.sourceforge.net)
 * @version $Author$ $Revision$ $Date$
 */
public final class BundleUtils {

    /** Generator header comment. */
    public static final String GENERATED_BY = 
            "#Generated by ResourceBundle Editor "
          + "(http://eclipse-rbe.sourceforge.net)";

    /** A table of hex digits */
    private static final char[] HEX_DIGITS = {
        '0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'
    };

    /** Special resouce bundle characters. */
    private static final String specialSaveChars = "=: \t\r\n\f#!";
    
    /** System line separator. */
    private static final String SYSTEM_LINE_SEPARATOR = 
            System.getProperty("line.separator");
    /** Forced line separators. */
    private static final String[] FORCED_LINE_SEPARATORS = new String[3];
    static {
        FORCED_LINE_SEPARATORS[RBEPreferences.NEW_LINE_UNIX] = "\\\\n";
        FORCED_LINE_SEPARATORS[RBEPreferences.NEW_LINE_WIN] = "\\\\r\\\\n";
        FORCED_LINE_SEPARATORS[RBEPreferences.NEW_LINE_MAC] = "\\\\r";
    }

    
    /**
     * Constructor.
     */
    private BundleUtils() {
        super();
    }

    /**
     * Parses a string and converts it to a <code>Bundle</code>.  The string is 
     * expected to match the documented structure of a properties file.
     * The returned bundle will have no <code>Locale</code> and no
     * <code>BundleGroup</code> associated to it.
     * @param properties the string containing the properties to parse
     * @return a new bundle
     */
    public static Bundle parseProperties(String properties) {
        Bundle bundle = new Bundle();
        String[] lines = properties.split("\r\n|\r|\n");
        
        boolean doneWithFileComment = false;
        StringBuffer fileComment = new StringBuffer();
        StringBuffer lineComment = new StringBuffer();
        StringBuffer line = new StringBuffer();
        for (int i = 0; i < lines.length; i++) {
            line.setLength(0);
            line.append(lines[i]);
        
            int equalPosition = line.indexOf("=");

            // parse comment line
            if (line.indexOf("#") == 0) {
                if (!doneWithFileComment) {
                    fileComment.append(line);
                    fileComment.append(SYSTEM_LINE_SEPARATOR);
                } else {
                    lineComment.append(line);
                    lineComment.append(SYSTEM_LINE_SEPARATOR);
                }
            // parse regular lines
            } else if (equalPosition >= 1) {
                doneWithFileComment = true;
                String comment = "";
                if (lineComment.length() > 0) {
                    comment = lineComment.toString();
                    lineComment.setLength(0);
                }
                while (line.lastIndexOf("\\") == line.length() -1) {
                    int lineBreakPosition = line.lastIndexOf("\\");
                    line.replace(
                            lineBreakPosition,
                            lineBreakPosition + 1, "");
                    if (++i <= lines.length) {
                        line.append(lines[i].trim());
                    }
                }
                String key = line.substring(0, equalPosition).trim();
                String value = line.substring(equalPosition + 1).trim();
                if (RBEPreferences.getConvertEncodedToUnicode()) {
                    key = BundleUtils.convertEncodedToUnicode(key);
                    value = BundleUtils.convertEncodedToUnicode(value);
                } else {
                    value = value.replaceAll("\\\\r", "\r");
                    value = value.replaceAll("\\\\n", "\n");
                }
                bundle.addEntry(new BundleEntry(key, value, comment));
            // handle blank or unsupported line
            } else {
                doneWithFileComment = true;
            }
        }
        bundle.setComment(fileComment.toString());
        return bundle;
    }
    
    /**
     * Generates a formatted string from a given <code>Bundle</code>.  The
     * returned string will conform to documented properties file structure.
     * @param bundle the bundle used to generate the string
     * @return the generated string
     */
    public static String generateProperties(Bundle bundle) {
        String lineBreak = SYSTEM_LINE_SEPARATOR;
        int numOfLineBreaks = RBEPreferences.getGroupLineBreaks();
        StringBuffer text = new StringBuffer();

        // Header comment
        String headComment = bundle.getComment();
        if (headComment != null && headComment.length() > 0) {
            if (RBEPreferences.getShowGenerator() 
                    && !headComment.startsWith(GENERATED_BY)) {
                text.append("#");
                text.append(GENERATED_BY);
                text.append(SYSTEM_LINE_SEPARATOR);
            }
            text.append(headComment);
        }
        
        // Format
        String group = null;
        int equalIndex = -1;
        for (Iterator iter = bundle.getKeys().iterator(); iter.hasNext();) {
            BundleEntry bundleEntry = bundle.getEntry((String) iter.next());
            String key = bundleEntry.getKey();
            String value = bundleEntry.getValue(); 
            String comment = bundleEntry.getComment();    
            
            // handle new lines in value
            if (value != null){
                if (RBEPreferences.getForceNewLineType()) {
                    value = value.replaceAll(
                            "\\r\\n|\\r|\\n", FORCED_LINE_SEPARATORS[
                                    RBEPreferences.getNewLineType()]);
                } else {
                    value = value.replaceAll("\r", "\\\\r");
                    value = value.replaceAll("\n", "\\\\n");
                }
            } else {
                value = "";
            }
            
            // handle group equal align and line break options
            if (RBEPreferences.getGroupKeys()) {
                String newGroup = getKeyGroup(key);
                if (newGroup == null || !newGroup.equals(group)) {
                    group = newGroup;
                    equalIndex = getEqualIndex(key, group, bundle);
                    for (int i = 0; i < numOfLineBreaks; i++) {
                        text.append(lineBreak);
                    }
                }
            } else {
                equalIndex = getEqualIndex(key, null, bundle);
            }
            
            // Build line
            if (RBEPreferences.getConvertUnicodeToEncoded()) {
                key = BundleUtils.convertUnicodeToEncoded(key);
                value = BundleUtils.convertUnicodeToEncoded(value);
            }
            if (comment != null && comment.length() > 0) {
                text.append(comment);
            }
            appendKey(text, key, equalIndex);
            appendValue(text, value, equalIndex);
            text.append(lineBreak);
        }
        return text.toString();
    }
    
    /**
     * Converts encoded &#92;uxxxx to unicode chars
     * and changes special saved chars to their original forms
     * This method was copied from <code>Properties.loadConvert(String)</code>.
     * @see java.util.Properties#loadConvert(java.lang.String)
     */
    public static String convertEncodedToUnicode(String theString) {
        char aChar;
        int len = theString.length();
        StringBuffer outBuffer = new StringBuffer(len);

        for (int x = 0; x < len;) {
            aChar = theString.charAt(x++);
            if (aChar == '\\') {
                aChar = theString.charAt(x++);
                if (aChar == 'u') {
                    // Read the xxxx
                    int value = 0;
                    for (int i = 0; i < 4; i++) {
                        aChar = theString.charAt(x++);
                        switch (aChar) {
                        case '0': case '1': case '2': case '3': case '4':
                        case '5': case '6': case '7': case '8': case '9':
                            value = (value << 4) + aChar - '0';
                            break;
                        case 'a': case 'b': case 'c':
                        case 'd': case 'e': case 'f':
                            value = (value << 4) + 10 + aChar - 'a';
                            break;
                        case 'A': case 'B': case 'C':
                        case 'D': case 'E': case 'F':
                            value = (value << 4) + 10 + aChar - 'A';
                            break;
                        default:
                            throw new IllegalArgumentException(
                                    "Malformed \\uxxxx encoding.");
                        }
                    }
                    outBuffer.append((char) value);
                } else {
                    if (aChar == 't')
                        aChar = '\t';
                    else if (aChar == 'r')
                        aChar = '\r';
                    else if (aChar == 'n')
                        aChar = '\n';
                    else if (aChar == 'f')
                        aChar = '\f';
                    outBuffer.append(aChar);
                }
            } else
                outBuffer.append(aChar);
        }
        return outBuffer.toString();
    }
    
    /**
     * Converts unicodes to encoded &#92;uxxxx
     * and writes out any of the characters in specialSaveChars
     * with a preceding slash
     * @see java.util.Properties#saveConvert(java.lang.String, boolean)
     */
    public static String convertUnicodeToEncoded(
            String theString /*, boolean escapeSpace */) {
        int len = theString.length();
        StringBuffer outBuffer = new StringBuffer(len * 2);

        for (int x = 0; x < len; x++) {
            char aChar = theString.charAt(x);
            if ((aChar < 0x0020) || (aChar > 0x007e)) {
                outBuffer.append('\\');
                outBuffer.append('u');
                outBuffer.append(toHex((aChar >> 12) & 0xF));
                outBuffer.append(toHex((aChar >> 8) & 0xF));
                outBuffer.append(toHex((aChar >> 4) & 0xF));
                outBuffer.append(toHex(aChar & 0xF));
            } else {
                outBuffer.append(aChar);
            }
        }
        return outBuffer.toString();
    }
    
    /**
     * Converts a nibble to a hex character
     * @param nibble  the nibble to convert.
     */
    private static char toHex(int nibble) {
        char hexChar = HEX_DIGITS[(nibble & 0xF)];
        if (!RBEPreferences.getConvertUnicodeToEncodedUpper()) {
            return Character.toLowerCase(hexChar);
        }
        return hexChar;
    }

    /**
     * Appends a value to resource bundle content.
     * @param text the resource bundle content so far
     * @param value the value to add
     * @param equalIndex the equal sign position
     */
    private static void appendValue(
            StringBuffer text, String value, int equalIndex) {
        if (value != null) {
            int lineLength = RBEPreferences.getWrapCharLimit() - 1;
            int valueStartPos = equalIndex;
            if (RBEPreferences.getSpacesAroundEqualSigns()) {
                valueStartPos += 3;
            } else {
                valueStartPos += 1;
            }
            
            // Break line after escaped new line
            if (RBEPreferences.getNewLineNice()) {
                value = value.replaceAll(
                        "(\\\\r\\\\n|\\\\r|\\\\n)",
                        "$1\\\\" + SYSTEM_LINE_SEPARATOR);
            }
            // Wrap lines
            if (RBEPreferences.getWrapLines() && valueStartPos < lineLength) {
                StringBuffer valueBuf = new StringBuffer(value);
                while (valueBuf.length() + valueStartPos > lineLength
                        || valueBuf.indexOf("\n") != -1) {
                    int endPos = Math.min(
                            valueBuf.length(), lineLength - valueStartPos);
                    String line = valueBuf.substring(0, endPos);
                    int breakPos = line.indexOf(SYSTEM_LINE_SEPARATOR);
                    if (breakPos != -1) {
                        endPos = breakPos + SYSTEM_LINE_SEPARATOR.length();
                        text.append(valueBuf.substring(0, endPos));
                    } else {
                        breakPos = line.lastIndexOf(' ');
                        if (breakPos != -1) {
                            endPos = breakPos + 1;
                            text.append(valueBuf.substring(0, endPos));
                            text.append("\\");
                            text.append(SYSTEM_LINE_SEPARATOR);
                        }
                    }
                    valueBuf.delete(0, endPos);
                    // Figure out starting position for next line
                    if (!RBEPreferences.getWrapAlignEqualSigns()) {
                        valueStartPos = RBEPreferences.getWrapIndentSpaces();
                    }
                    for (int i = 0; i < valueStartPos; i++) {
                        text.append(' ');
                    }
                }
                text.append(valueBuf);
            } else {
                text.append(value);
            }
        }
    }

    /**
     * Appends a key to resource bundle content.
     * @param text the resource bundle content so far
     * @param key the key to add
     * @param equalIndex the equal sign position
     */
    private static void appendKey(
            StringBuffer text, String key, int equalIndex) {
        text.append(key);
        for (int i = 0; i < equalIndex - key.length(); i++) {
            text.append(' ');
        }
        if (RBEPreferences.getSpacesAroundEqualSigns()) {
            text.append(" = ");
        } else {
            text.append("=");
        }
    }
    
    /**
     * Gets the group from a resource bundle key.
     * @param key the key to get a group from
     * @return key group
     */
    private static String getKeyGroup(String key) {
        IPreferenceStore prefs = 
                RBEPlugin.getDefault().getPreferenceStore();

        String sep = RBEPreferences.getKeyGroupSeparator();
        int deepness = RBEPreferences.getGroupLevelDeepness();
        int endIndex = 0;
        int levelFound = 0;
        
        for (int i = 0; i < deepness; i++) {
            int sepIndex = key.indexOf(sep, endIndex);
            if (sepIndex != -1) {
                endIndex = sepIndex + 1;
                levelFound++;
            }
        }
        if (levelFound != 0) {
            if (levelFound < deepness) {
                return key;
            }
            return key.substring(0, endIndex - 1);
        }
        return null;
    }
    
    /**
     * Gets the position where the equal sign should be located for
     * the given group.
     * @param key resource bundle key
     * @param group resource bundle key group
     * @param data bundle content
     * @return position
     */
    private static int getEqualIndex(String key, String group, Bundle bundle) {
        int equalIndex = -1;
        boolean alignEquals = RBEPreferences.getAlignEqualSigns();
        boolean groupKeys = RBEPreferences.getGroupKeys();
        boolean groupAlignEquals = RBEPreferences.getGroupAlignEqualSigns();

        // Exit now if we are not aligning equals
        if (!alignEquals || groupKeys && !groupAlignEquals 
                         || groupKeys && group == null) {
            return key.length();
        }
        
        // Get equal index
        for (Iterator iter = bundle.getKeys().iterator(); iter.hasNext();) {
            String iterKey = (String) iter.next();
            if (!groupKeys || groupAlignEquals && iterKey.startsWith(group)) {
                int index = iterKey.length();
                if (index > equalIndex) {
                    equalIndex = index;
                }
            }
        }        
        return equalIndex;
    }
}
